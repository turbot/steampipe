package steampipeconfig

import (
	"strings"

	"github.com/hashicorp/hcl/v2"
	"github.com/hashicorp/hcl/v2/gohcl"
	"github.com/hashicorp/hcl/v2/hclsyntax"
	"github.com/turbot/steampipe/steampipeconfig/modconfig"
)

func parseMod(block *hcl.Block) (*modconfig.Mod, hcl.Diagnostics) {
	var diags hcl.Diagnostics

	content, diags := block.Body.Content(modSchema)
	if diags.HasErrors() {
		return nil, diags
	}
	mod := &modconfig.Mod{
		ShortName: &block.Labels[0],
	}
	moreDiags := parseModAttributes(content, mod)
	if moreDiags.HasErrors() {
		diags = append(diags, moreDiags...)
	}

	for _, block := range content.Blocks {
		switch block.Type {
		// TODO add parsing of requires block
		//case "mod_depends":
		//	modDependency, moreDiags := parseModVersion(block)
		//	if moreDiags.HasErrors() {
		//		diags = append(diags, moreDiags...)
		//		break
		//	}
		//	mod.ModDepends = append(mod.ModDepends, modDependency)
		//case "plugin_depends":
		//	pluginDependency, moreDiags := parsePluginDependency(block)
		//	if moreDiags.HasErrors() {
		//		diags = append(diags, moreDiags...)
		//		break
		//	}
		//	mod.PluginDepends = append(mod.PluginDepends, pluginDependency)

		case "opengraph":
			opengraph, moreDiags := parseOpenGraph(block)
			if moreDiags.HasErrors() {
				diags = append(diags, moreDiags...)
				break
			}
			mod.OpenGraph = opengraph
		}
	}

	return mod, diags
}

func parseModAttributes(content *hcl.BodyContent, mod *modconfig.Mod) hcl.Diagnostics {
	var diags hcl.Diagnostics
	diags = append(diags, parseAttribute("color", &mod.Color, content)...)
	diags = append(diags, parseAttribute("description", &mod.Description, content)...)
	diags = append(diags, parseAttribute("documentation", &mod.Documentation, content)...)
	diags = append(diags, parseAttribute("icon", &mod.Icon, content)...)
	diags = append(diags, parseAttribute("labels", &mod.Labels, content)...)
	diags = append(diags, parseAttribute("title", &mod.Title, content)...)

	return diags
}

func parseAttribute(name string, dest interface{}, content *hcl.BodyContent) hcl.Diagnostics {
	var diags hcl.Diagnostics
	if content.Attributes[name] != nil {
		moreDiags := gohcl.DecodeExpression(content.Attributes[name].Expr, nil, dest)
		if moreDiags.HasErrors() {
			diags = append(diags, moreDiags...)
		}
	}
	return diags
}

func parseModVersion(block *hcl.Block) (*modconfig.ModVersion, hcl.Diagnostics) {
	var diags hcl.Diagnostics
	var dest = &modconfig.ModVersion{}

	diags = gohcl.DecodeBody(block.Body, nil, dest)
	if diags.HasErrors() {
		return nil, diags
	}

	return dest, nil
}

func parsePluginDependency(block *hcl.Block) (*modconfig.PluginDependency, hcl.Diagnostics) {
	var diags hcl.Diagnostics
	var dest = &modconfig.PluginDependency{}

	diags = gohcl.DecodeBody(block.Body, nil, dest)
	if diags.HasErrors() {
		return nil, diags
	}

	return dest, nil
}

func parseOpenGraph(block *hcl.Block) (*modconfig.OpenGraph, hcl.Diagnostics) {
	var diags hcl.Diagnostics
	var dest = &modconfig.OpenGraph{}

	diags = gohcl.DecodeBody(block.Body, nil, dest)
	if diags.HasErrors() {
		return nil, diags
	}

	return dest, nil
}

func parseQuery(block *hcl.Block) (*modconfig.Query, hcl.Diagnostics) {
	var diags hcl.Diagnostics
	var q = &modconfig.Query{}

	diags = gohcl.DecodeBody(block.Body, nil, q)
	if diags.HasErrors() {
		return nil, diags
	}

	q.ShortName = &block.Labels[0]
	return q, nil
}

func parseControl(block *hcl.Block) (*modconfig.Control, hcl.Diagnostics) {
	var diags hcl.Diagnostics
	var c = &modconfig.Control{}

	diags = gohcl.DecodeBody(block.Body, nil, c)
	if diags.HasErrors() {
		return nil, diags
	}

	c.ShortName = &block.Labels[0]
	return c, nil
}

func parseControlGroup(block *hcl.Block) (*modconfig.ControlGroup, hcl.Diagnostics) {
	var diags hcl.Diagnostics
	var c = &modconfig.ControlGroup{}

	diags = gohcl.DecodeBody(block.Body, nil, c)
	if diags.HasErrors() {
		return nil, diags
	}

	c.ShortName = &block.Labels[0]
	return c, nil
}

func getMetadataForParsedResource(resourceName string, block *hcl.Block, fileData map[string][]byte) *modconfig.ResourceMetadata {
	body := block.Body.(*hclsyntax.Body)

	return &modconfig.ResourceMetadata{
		ResourceName:     resourceName,
		FileName:         body.SrcRange.Filename,
		StartLineNumber:  body.SrcRange.Start.Line,
		EndLineNumber:    body.SrcRange.End.Line,
		IsAutoGenerated:  false,
		SourceDefinition: getSourceDefinition(body.SrcRange, fileData),
	}
}

func getSourceDefinition(sourceRange hcl.Range, fileData map[string][]byte) string {
	filename := sourceRange.Filename
	fileBytes, ok := fileData[filename]
	if !ok {
		return ""
	}

	source := strings.Join(
		strings.Split(string(fileBytes), "\n")[sourceRange.Start.Line-1:sourceRange.End.Line], "\n")
	return source
}
