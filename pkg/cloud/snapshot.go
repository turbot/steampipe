package cloud

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/spf13/viper"
	"github.com/turbot/steampipe/pkg/constants"
	"github.com/turbot/steampipe/pkg/dashboard/dashboardtypes"
	"io"
	"net/http"
	"strings"
)

func UploadSnapshot(snapshot *dashboardtypes.SteampipeSnapshot, share bool) (map[string]interface{}, error) {

	cloudWorkspace := viper.GetString(constants.ArgWorkspace)
	parts := strings.Split(cloudWorkspace, "/")
	if len(parts) != 2 {
		return nil, fmt.Errorf("failed to resolve username and workspace handle from workspace %s", cloudWorkspace)
	}
	user := parts[0]
	worskpaceHandle := parts[1]

	url := fmt.Sprintf("https://%s/api/v0/user/%s/workspace/%s/snapshot",
		viper.GetString(constants.ArgCloudHost),
		user,
		worskpaceHandle)

	// get the cloud token (we have already verifuied this was provided)
	token := viper.GetString(constants.ArgCloudToken)
	// create a 'bearer' string by appending the access token
	var bearer = "Bearer " + token

	client := &http.Client{}

	// set the visibility
	visibility := "project"
	if share {
		visibility = "anyone_with_link"
	}

	body := struct {
		Data       *dashboardtypes.SteampipeSnapshot `json:"data"`
		Tags       []string                          `json:"tags"`
		Visibility string                            `json:"visibility"`
	}{
		Data: snapshot,
		//Tags: []string{"generated by Styaempipe CLI"},
		Visibility: visibility,
	}

	bodyStr, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(bodyStr))
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("Content-Type", "application/json")
	req.Header.Add("Authorization", bearer)

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if resp.StatusCode < 200 || resp.StatusCode > 206 {
		return nil, fmt.Errorf("%s", resp.Status)
	}
	defer resp.Body.Close()
	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	// TODO ```{
	//"created_at": "string",
	//"created_by": {
	//"avatar_url": "string",
	//"created_at": "string",
	//"display_name": "string",
	//"handle": "string",
	//"id": "string",
	//"preview_access_mode": "string",
	//"status": "string",
	//"updated_at": "string",
	//"url": "string",
	//"version_id": 0
	//},
	//"created_by_id": "string",
	//"dashboard_name": "string",
	//"dashboard_title": "string",
	//"id": "string",
	//"identity_id": "string",
	//"inputs": null,
	//"schema_version": "string",
	//"state": "string",
	//"tags": null,
	//"updated_at": "string",
	//"updated_by": {
	//"avatar_url": "string",
	//"created_at": "string",
	//"display_name": "string",
	//"handle": "string",
	//"id": "string",
	//"preview_access_mode": "string",
	//"status": "string",
	//"updated_at": "string",
	//"url": "string",
	//"version_id": 0
	//},
	//"updated_by_id": "string",
	//"version_id": 0,
	//"visibility": "string",
	//"workspace_id": "string"
	//}
	var result map[string]interface{}
	err = json.Unmarshal(bodyBytes, &result)
	if err != nil {
		return nil, err
	}
	return result, nil
}
